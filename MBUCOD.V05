	.TITLE MBUCOD V05
;MICRO CODE FOR 2901 "MATH-BOX"
	.SBTTL ***********************************
	.SBTTL *                                 *
	.SBTTL *PROGRAMMER: MIKE ALBAUGH         *
	.SBTTL *                                 *
	.SBTTL *CHECKED BY:                      *
	.SBTTL *                                 *
	.SBTTL ***********************************
	.REPT 0
*******************************************************************************
	Copyright 1980 Atari, Inc.  Unauthorized reproduction, adaptation,
   distribution, performance or display of this computer program or the
   associated audiovisual work is strictly prohibited.
*******************************************************************************
	.ENDR
	.RADIX 16
	.NLIST CND,BYT
	.LIST MEB
ROM=1				;PRODUCE ROM TAPE IF "ROM" DEFINED
	.ENABL LC
	.ASECT
	.REPT 0
	
DATE INITIATED: 31-JULY-79
	
PROJECT #: 22903
	
DISK #: 87 & B18
	
HARDWARE REQUIREMENTS:
	MATH-BOX 2901 SYSTEM
	
MEMORY REQUIREMENTS:
	256 X 24 BITS OF MICRO-CODE
	FOR SYSTEM DEVELOPMENT AND
	LISTING PURPOSES, THIS IS MAPPED
	TO 2K BYTES, OF WHICH THE FIRST
	THREE BYTES OF EACH EIGHT ARE
	USED. IF THE SYMBOL "ROM" IS
	DEFINED THE CODE WILL ALSO
	BE ASSEMBLED INTO 3 PAGES,
	1 BYTE OF EACH WORD INTO 
	EACH PAGE.
	
INTERRUPT REQUIREMENTS:
	NOT APPLICABLE
	
ASSEMBLY CMD STRING:
	MBUCOD/A
	
LINK CMD STRING:
	DK1:MBUCOD/L=MBUCOD
	***PUT DISK D45 IN DX0
	.R PIP
	FL0:MBUCOD.LDA=DK1:MBUCOD.LDA/B

	FOR ROMS: LINK CMD STRING

	DK1:MBUCOD=MBUCOD

	.R ROM

	START ADDRESS 6800

	(THIS WILL PRODUCE ROM TAPE FOR THE MBU MICRO CODE)

	.R ROM
	START ADDRESS 8400
	(THIS WILL PRODUCE TAPE FOR THE MBU MAPPING PROM 32X8, 82S123)
	
PROGRAM DESCRIPTION:
	THIS PROGRAM EMULATES THE MALIBU-
	MATRIX-MULTIPLY AND LONG-DIVIDE
	HARDWARE ON A MICRO-PROGRAMMED
	PROCESSOR BUILT FROM 4 2901'S
	ALL ELSE IS GRAVY.
	REV LEVEL:
	5) CLEARS YPL LSB'S ON POST-ADD DIVIDE (GREG RIVERS)

	4) ADD "DSTNCE" FOR BATTLE ZONE (ED ROTBERG)

	3) ADD "CLIP" FOR MALIBU (ED LOGG)

	2) SHORTEN DIVIDE

	1) FIX "2-MSB" DIVIDE BUG

	.ENDR
	.PAGE
	.SBTTL DEFINITIONS
	.GLOBL PSTART,MULXP,MULYP,DSPQ,DIVID
	.SBTTL	PRIMITIVES
	.MACRO $OUT ...1,...2		;OUTPUT 3 BYTES OF UCODE
	.BYTE ...1&65280./256.,...1&255.,...2
	.IF DF,ROM
	.NLIST
.SAVE	=.
.	=.SAVE-3-PSTART/8+RSTART
	.BYTE ...1&65280./256.
.	=.+255.
	.BYTE ...1&255.
.	=.+255.
	.BYTE ...2
.	=.SAVE
	.LIST
	.ENDC
	.BLKB 5				;BUMP TO NEXT /8 LOC.
	.ENDM $OUT

	.MACRO EVAL A,B,C,D,E,F,G,H
	.IF NB,A
	A B C D E F G H
	.IFF				;IF NOTHING LEFT ON LINE
...2	=...2?16.			;DEFAULT DEST=NOP
	$OUT ...1,...2			;OUTPUT CODE
	...1=0				;RESET TEMP DATA
	...2=0
	...M0=0				;RESET TEMP MASK
	...M2=0
	.ENDC
	.ENDM EVAL

	.MACRO TSTCNF M0,M2,D0,D2	;TEST FOR CONFLICT
...3	=...M0&<'M0'>
...4	=...M2&<'M2'>
...3	=...1?<'D0'>&...3
...4	=...2?<'D2'>&...4

	.IF NE,...3!...4
	.ERROR	;CONFLICT IN BYTES
	.WORD ...1,...2
	.WORD ...M0,...M2
	.WORD D0,D2
	.WORD M0,M2
	.=.-16.				;BACKSPACE LOC CTR
	.ENDC				;NE,...3!...4
	.ENDM TSTCNF

	.SBTTL	ALU FUNCTIONS

	.MACRO ADD A,B,C,D,E,F,G,H
	EVSRC 0,A B C D E F G H		;FUNC=0
	.ENDM

	.MACRO CADD A,B,C,D,E,F,G,H
...2	=2			;SET "MULT BIT
...M2	=2
	EVSRC 0,A B C D E F G H	;FUNC=0
	.ENDM

	.MACRO SUBR A,B,C,D,E,F,G,H
...2	=1			;SET CARRY
	EVSRC 1,A B C D E F G H
	.ENDM

	.MACRO SUBS A,B,C,D,E,F,G,H
...2	=1			;SET CARRY
	EVSRC 2,A B C D E F G H
	.ENDM

	.MACRO OR A,B,C,D,E,F,G,H
	EVSRC 3,A B C D E F G H
	.ENDM

	.MACRO AND A,B,C,D,E,F,G,H
	EVSRC 4,A B C D E F G H
	.ENDM

	.MACRO BIC A,B,C,D,E,F,G,H
	EVSRC 5,A B C D E F G H
	.ENDM

	.MACRO NOTRS A,B,C,D,E,F,G,H
	EVSRC 5,A B C D E F G H
	.ENDM

	.MACRO EXOR A,B,C,D,E,F,G,H
	EVSRC 6,A B C D E F G H
	.ENDM

	.MACRO EXNOR A,B,C,D,E,F,G,H
	EVSRC 7,A B C D E F G H
	.ENDM

	.MACRO DEC A,B,C,D,E,F,G,H
	EVSRC 1 Z A B C D E F G H	;CLC, SUBR
	.ENDM

	.SBTTL	SOURCE MODES

	.MACRO SOC VAL,MSK
	TSTCNF MSK,0,VAL,0		;TEST FOR BIT CONFLICT
...1	=...1!<'VAL'>
...M0	=...M0!<'MSK'>
	.ENDM

	.MACRO EVSRC OP,.A,.B,.C,.D,.E,.F,.G,.H
...1	=OP!...1
...M0	=7!...M0
	.IF NB,.B
SOMADD	=0
ZDF	=0
	.IF IDN,.B,Q
	.IF IDN,.A,Z
	SOC 32.,240.			;SET ZQ
ZDF	=1
	.ENDC				;IDN,.A,Z
	.IF IDN,.A,D
	SOC 224.,240.			;SET DQ
ZDF	=1
	.ENDC				;IDN,.A,D
	.IF EQ,ZDF			;IF NEITHER D NOR Z
	SOC .A*4096.,61680.		;SET AQ, SET AND PROTECT A ADDR.
	.ENDC				;EQ,ZDF
SOMADD	=1				;SOME ADDRESS MODE USED
	.ENDC				;IDN,.B,Q
	.IF IDN,.A,ZB
	SOC .B*16.+.C*256.+48.,65520.	;SET ZB, SET& PROT A,B
SOMADD	=2
	.ENDC				;IDN,.A,ZB
	.IF IDN,.A,ZA
	SOC .B*16.+.C*256.+192.,65520.	;SET ZA, SET & PROT A,B
SOMADD	=2
	.ENDC				;IDN,.A,ZA
	.IF EQ,SOMADD
	.IF IDN,.A,Z			;IF JUST Z, USE ZB, PROT ONLY B
	SOC .B*256.+48.,4080.
SOMADD	=1
	.ENDC				;IDN,.A,Z
	.IF IDN,.A,D
	.IF IDN,.B,Z
	SOC 240.,240.			;SET DZ
ZDF	=1
SOMADD	=1
	.ENDC				;IDN,.B,Z
	.IF EQ,ZDF			;IF D, NOT Q OR Z
	SOC .B*4096.+208.,61680.		;SET DA,SET & PROT A
SOMADD	=1
	.ENDC				;EQ,ZDF
	.ENDC				;IDN,.A,D
	.ENDC				;EQ, SOMADD
	.IF EQ,SOMADD			;IF NO OTHER MODE
	SOC .A*16.+.B*256.+16.,65520.	;USE AB, SET & PROT A,B
	.ENDC				;EQ,SOMADD
	.IFF				;NB,.B
	.ERROR	;SYNTAX-SOURCE OPERANDS
	.ENDC				;NB,.B
	.IF GT,SOMADD-1
	EVAL .D .E .F .G .H
	.IFF
	EVAL .C .D .E .F .G .H		;PARSE REMAINDER
	.ENDC
	.ENDM EVSRC
	
	.SBTTL	DESTINATION MODES
	.MACRO DOC VAL,MSK
	TSTCNF 0,MSK,0,VAL*16.?16.
...2	=...2!<'VAL'*16.?16.>
...M2	=...M2!<'MSK'>
	.ENDM
	
	.MACRO QREG .D,.E,.F,.G,.H,.I
	DOC 0,112.
	EVAL .D .E .F .G .H
	.ENDM
	
	.MACRO NOP .D,.E,.F,.G,.H,.I
	DOC 1,112.
	EVAL .D .E .F .G .H
	.ENDM
	
	.MACRO RAMA .D,.E,.F,.G,.H,.I
	DOC 2,112.
	EVAL .D .E .F .G .H
	.ENDM
	
	.MACRO RAMF .D,.E,.F,.G,.H,.I
	DOC 3,112.
	EVAL .D .E .F .G .H
	.ENDM
	
	.MACRO RAMQD .D,.E,.F,.G,.H,.I
	DOC 4,112.
	EVAL .D .E .F .G .H
	.ENDM
	
	.MACRO RAMD .D,.E,.F,.G,.H,.I
	DOC 5,112.
	EVAL .D .E .F .G .H
	.ENDM

	.MACRO RAMQU .D,.E,.F,.G,.H,.I
	DOC 6,112.
	EVAL .D .E .F .G .H
	.ENDM

	.MACRO RAMU
	DOC 7,112.
	EVAL .D .E .F .G .H
	.ENDM
	
	.SBTTL	MISC & JMP
	.MACRO LDAB .E,.F,.G,.H,.I
	.IF B,.E			;IF NEXT IS BLANK,
...2	=...2!128.			;JUST SET BIT
...M2	=...M2!128.			;MARK AS USED
	.IFF
	TSTCNF 65280.,128.,.E*256.,128.	;CHECK CONFLICTS
...1	=...1!<.E*256.>			;SET A,B
...M0	=...M0!65280.			;PROTECT A,B
...2	=...2!128.			;SET LDAB BIT
...M2	=...M2!128.			;PROTECT IT
	.ENDC
	EVAL .F .G .H
	.ENDM
	
	.MACRO BREG .D,.E,.F,.G,.H
	TSTCNF 3840.,0,256.*.D,0
...1	=256.*.D!...1
	EVAL .E .F .G .H
	.ENDM
	
	.MACRO SIGN .F,.G,.H,.I,.J,.K
	TSTCNF 0,8.,0,8.
...2	=...2!8.
...M2	=...M2!8.
	EVAL .F .G .H
	.ENDM

	.MACRO UNSIGN .F,.G,.H,.I,.J,.K
	TSTCNF 0,8.,0,0
...M2	=...M2!8.
	EVAL .F .G .H
	.ENDM
	
	.MACRO SEC .F,.G,.H,.I,.J,.K
...2	=1!...2
...M2	=1!...M2
	EVAL .F .G .H .I .J .K
	.ENDM

	.MACRO CLC .F,.G,.H,.I,.J,.K
...2	=-2&...2
...M2	=1!...M2
	EVAL .F .G .H .I .J .K
	.ENDM

	.MACRO JP .F,.G,.H,.I,.J,.K
...2	=...2!4
...M2	=...M2!4
	.IF NB,.F
	LJT .F,.G,.H			;FORCE LOAD OF TARGET
	.IFF
	EVAL .F .G .H
	.ENDC
	.ENDM
	
	.MACRO JMP .F,.G,.H,.I,.J,.K
	UNSIGN JP,.F .G .H
	.ENDM
	
	.MACRO JPL .F,.G,.H,.I,.J,.K
	SIGN JP,.F .G .H
	.ENDM

	.MACRO LJT .F,.G,.H,.I,.J,.K
	LDAB <'.F-PSTART/8> .G .H
	.ENDM
	
	.MACRO STALL .F,.G,.H,.I,.J,.K
	.IF NE,^C...1&...M0&8
	.ERROR	;-NO STALL ALLOWED
	.IFF
...1	=...1!8.
...M0	=...M0!8.
	.ENDC			;NE,^C...1&...M0&8
	EVAL .F .G .H
	.ENDM

	.MACRO LDH A,B,C,D,E,F,G,H
;LOW- OR Z,B RAMF
;HIGH- OR D,Z RAMF
...1	=A*256.+179.			;^H100+^H0B3
...M0	=4095.			;^H0FFF
...2	=32.			;^H20
...M2	=112.			;^H70
	EVAL B C D E F G H
	.ENDM

	.MACRO LDL A,B,C,D,E,F,G,H
;LOW- OR D,Z RAMF
;HIGH- OR Z,B RAMF
...1	=A*256.+115.			;OR D,0(B="A")
...M0	=4095.
...2	=32.				;RESULT TO B, WHICH IS "A"
...M2	=112.
	EVAL B C D E F G H
	.ENDM
	.SBTTL	CONSTANTS
PSTART	=6000
RSTART	=6800
	.SBTTL	REGISTER NAMES
RA	=0
RB	=RA+1			;PARAMS FOR MATRIX MULT
RE	=RB+1
RF	=RE+1
RX	=RF+1
RY	=RX+1
RN	=RY+1			;NUMBER OF BITS IN DIVIDE
RXP	=RN+1
RYP	=RXP+1
RYPL	=RYP+1
RZL	=RYPL+1
RZH	=RZL+1
T3	=15.
T2	=T3-1
T1	=T2-1
T0	=T1-1
X3	=T2
Y3	=T3
X1	=RXP
Y1	=RYP
X2	=RX
Y2	=RY
RC	=RE
RD	=RF
	.PAGE
	.SBTTL MICRO-ROUTINES
	.=PSTART
	.SBTTL	POWER-ON DIAGNOSTIC
DIAG:	EXNOR	0,0,QREG		;MAKE Q=-1
1$:	ADD	Z,Q,JPL 1$		;LOOP HERE IS BAD "SIGN"
	SUBS	Z,Q,JPL 3$		;JMP SHOULD TAKE
2$:	ADD	Z,Q,STALL JMP 2$	;LOOP OR STALL
3$:	ADD	Z,Q,BREG 0,RAMF		;R0:=-1
	...1=64.+4
	BREG 1 RAMF
; ABOVE IS "AND ZA,R0,1,RAMF"	  FOR THE LOW BYTE,
; AND	   "AND R0,Q,BREG 1,RAMF" FOR THE HIGH BYTE,
; LEAVING R1=0FF00
	AND	Z,Q,QREG		;Q:=0
4$:	ADD	1,1,RAMQD,SIGN		;SET Q0 LATCH=0, PRESERVE R1
	CADD	0,1,RAMQD		;SHOULD JUST SHIFT R1,Q DOWN A BIT
	ADD	Z,Q JPL 4$		;LOOP 8 TIMES (UNTIL Q=8000)
5$:	ADD	Z,1,RAMQU		;BACK UP A BIT, LEAVING Q=0
	SUBS	Z,Q JPL 7$		;SHOULD ALWAYS JMP
					; (Q=0 IF Q0 INPUT WORKS)
6$:	ADD	Z,Q,STALL,JMP 6$	;NOISE ON Q0 LINE LOOPS/STALLS HERE
7$:	LJT	5$
	ADD	Z,1,JPL			;SHOULD LOOP 8 TIMES
					; ( UNTIL R1=FF00 AGAIN )
	JMP	4$			;REPEAT INDEFINITELY
	.PAGE
	.SBTTL	REG-DISPLAY
RDISP:
RNUM	=0
	.REPT RN		;DO REGS UP TO RN
	OR Z,RNUM NOP STALL
RNUM	=RNUM+1
	.ENDR
	AND Z,Q QREG JMP CLRNH	;Q:=0, GO TO CLR-RN-HIGH
RNUM	=RNUM+1
	.REPT 15.-RN		;CONTINUE FOR REGS AFTER RN
	OR Z,RNUM NOP STALL
RNUM	=RNUM+1
	.ENDR
	.SBTTL	 REG-STORE
RSTO:
RNUM	=0
	.REPT 16.
	LDL RNUM LDAB RNUM+16. JMP
	LDH RNUM LDAB RNUM+16. JMP
RNUM	=RNUM+1
	.ENDR
DSPQ:	OR Z,Q,STALL
SYHSM:	LDH RY JMP MULXP		;STORE Y HI, START MULT
SYHSMP:	LDH RY			;STORE Y HI, START MULT (POST)
;FALL THROUGH TO "POST-ADD" MULT
	.PAGE
	.SBTTL	 FORM X' & 'Y
;ENTER @ MULXPP FOR "POST-ADD",WHICH FALLS
;THROUGH TO DIVIDE Y'/X'
;ENTER @ MULXP FOR "PRE-SUB"
MULXPP:	AND Z T3,RAMF	;SET MARK+ (POST-ADD)
	JMP MULXPC
MULXP:	EXNOR T3,T3,RAMF		;SET MARK-(PRE-SUB)
	SUBR RE,RX,RAMF
	SUBR RF,RY,RAMF
MULXPC:	ADD ZA,RA,T1,RAMF	;T1:=A
	ADD ZA,RX,0C,QREG,JPL 10$	;Q:=X IF +THEN 10$
	SUBS Z,Q,QREG		;Q:=-Q
	SUBS Z,T1,RAMF	;ALSO NEGATE A
10$:	SUBR T0,T0,RAMQD,UNSIGN	;CLR T0,START MULT
	.REPT 16.
	CADD T1,T0,RAMQD,SIGN
	.ENDR
	ADD Z,Q,BREG T2 RAMF	;T2:=Q(RXP LOW)

;AT THIS POINT T2,RXP CONTAIN 32-BIT (X)*A

	SUBS ZA,RB,T1,RAMF	;T1:=-B
	LJT 40$
	ADD Z,RY,QREG,JPL	;Q:=Y,IF + THEN 40$
	SUBS Z,Q,QREG		;ELSE Q:=-Q, T1=-T1
	SUBS Z,T1,RAMF	
40$:	SUBR RXP,RXP,RAMQD,UNSIGN	;CLR RXP,START MULT
	.REPT 16.
	CADD T1,RXP,RAMQD,SIGN
	.ENDR
	ADD T0,RXP,RAMF		;FORM HIGH WD OF X'
	ADD Z,T2,RAMD,UNSIGN	;LSR LOW WORD OF FIRST PARTIAL
	ADD Z,Q,BREG T0,RAMD UNSIGN	;LSR LOW WORD OF SECOND PARTIAL
	ADD T0,T2,QREG		;Q=(LOW WD SUM)/2
	ADD Z,Q,JPL 50$		;TEST D15 OF SUM,SKIP IF 0
	ADD Z,RXP,SEC,RAMF	;ADD "CARRY" TO HIGH WD
50$:	LJT 60$
	ADD Z,T3,JPL		;TST MARK (T3) IF +, IS POST ADD
	ADD Z,RXP STALL	
;STALL WITH X-PRIME @ OUTPUT 46.-49. CYCLES
60$:	ADD RE,RXP,RAMF		;POST-ADD

MULYP:	ADD ZA,RB,T1,RAMF	;T1:=B
	LJT 10$
	ADD Z,RX,QREG,JPL	;Q:=X-E,IF + THEN 10$
	SUBS Z,Q,QREG		;Q:=-Q

	SUBS ZB,T1,T1,RAMF	;RB:=-RB
10$:	SUBR T0,T0,RAMQD,UNSIGN	;CLR T0,START MULT
	.REPT 16.
	CADD T1,T0,RAMQD,SIGN
	.ENDR
	ADD Z,Q,BREG RYPL RAMF
;AT THIS POINT T0,RYPL CONTAIN 32-BIT (X-E)*B

	ADD ZA,RA,T1,RAMF	;T1:=A
	LJT 30$
	ADD Z,RY,QREG,JPL	;Q:=Y-F, IF + THEN 30$
	SUBS Z,Q,QREG		;ELSE NEG Q,RA
	SUBS Z,T1,RAMF
30$:	SUBS RYP,RYP,RAMQD,UNSIGN	;CLR RYP,START MUL
	.REPT 16.
	CADD T1,RYP,RAMQD,SIGN
	.ENDR
	ADD T0,RYP,RAMF		;FORM HI WD OF Y'
	ADD Z,RYPL,RAMD UNSIGN	;RYPL/2
	ADD Z,Q,BREG T0 RAMD UNSIGN	;Q/2
	ADD T0,RYPL RAMF	;RYPL=(RYPL+Q)/2
	AND Z,Q,QREG LJT 40$	;CLR Q (FOR SHIFT)
	ADD Z,RYPL,RAMQU JPL	;RE-ALIGN RYPL,BCC
	ADD Z,RYP RAMF SEC	;ADD CARRY TO HIGH WD
40$:	LJT 60$
	ADD Z,T3,JPL		;TST MARK(T3). IF +, POST ADD
	ADD Z,RYP,RAMF,STALL

;STALL WITH Y-PRIME @ OUTPUT 44-50 CYCLES
;FOR POST-ADD, ADD F TO Y' HIGH, THEN CLEAR 8 LSB OF Y' LOW
60$:	ADD RF,RYP,RAMF		;POST-ADD
	EXNOR 0,0 QREG		;Q:=FFFFF
	...1=RYPL*4352.+68.
;ABOVE LINE DOES "AND ZA,RYPL,RYPL" ON LOW BYTE (CLEARING IT)
;	AND "AND RYPL,Q" ON HIGH BYTE (LEAVING IT)
	RAMF			;FINISH ABOVE
;NOW FALL THROUGH TO DIVIDE

	.PAGE
	.SBTTL DIVIDES
	.SBTTL	Y'/X'
DIVYP:	ADD ZA,RYPL,T0 RAMF		;T0:= Y'L
	ADD Z,RYP QREG			;Q:= Y'H
	JMP DIVS
	.SBTTL CLR RN HIGH
CLRNH:	SUBR Z,Q QREG CLC	;Q:=0FFFF
...1	=RN*4352.+132.
;ABOVE DOES "AND ZA,RN,RN" ON HIGH BYTE, "AND RN,Q" ON LOW
	RAMF STALL		;FINISH ABOVE
;I KNOW THIS IS A FUNNY PLACE FOR IT, BUT IF IT FITS, USE IT

	.SBTTL	Z/X'
DIVZ:	ADD ZA,RZL,T0 RAMF		;T0:= ZL
	ADD Z,RZH QREG			;Q:= ZH

; FALL THROUGH TO SIGNED DIVIDE

	.SBTTL	SIGNED DIVIDE
DIVS:	EXOR RXP,Q,BREG T2 RAMF		;SAVE SIGN OF QUOTIENT

; SET (T1,Q):= | Q,T0 |

	LJT 20$
	ADD Z,Q,BREG T1,RAMF JPL	;T1:=Q  SKIP IF +
	SUBS Z,Q,BREG T1,RAMF CLC	;ELSE T1:= ^C(Q)
	LJT 10$
	SUBS Z,T0,QREG,CLC,JPL		;Q:=^C(T0) SKIP IF +
	ADD Z,Q,SEC,JPL 10$		;"TRIAL ADD" SKIP IF NO CARRY
	ADD  Z,T1,SEC,RAMF		;ELSE BUMP T1
10$:	ADD  Z,Q,QREG,SEC JMP 30$	;REAL INC Q, GO CHECK RXP
20$:	ADD  Z,T0,QREG			;JUST SET Q:=T0 IF T1 +
30$:	LJT  DIVID
	ADD ZA,RXP,T0,RAMF JPL		;T0:=RXP, IF + GOTO DIVID
	SUBS ZA,RXP,T0,RAMF		;ELSE NEGATE

; FALL THROUGH TO UNSIGNED DIVIDE
	.SBTTL	UNSIGNED DIVIDE

;Assumes DivisoR & DividenD both +, DR>DD
;Does N cycle divide T1,Q(31 bits)/T0(15 bits)
;Stalls with quot in Q and on output

DIVID:	OR   ZA,RN,T3,RAMF		;SET COUNT
1$:	SUBR T0,T1 RAMF			;TRIAL SUB
	ADD ZA,T1,2,JPL 2$		;TST T1,BPL
	ADD T0,T1,RAMQU,LJT 1$		;ELSE RESTORE & SHIFT UP SHIFT
	DEC  T3 RAMF JPL		;SOB CNT,1$
	JMP  3$
2$:	ADD Z,T1,RAMQU		;SHIFT UP
	ADD  Z,Q,QREG,SEC,LJT 1$	;SET QUOT BIT
	DEC  T3 RAMF JPL		;SOB CNT 1$
3$:	LJT  4$
	ADD  Z,T2 JPL			;SKIP IF LIKE SIGNS IN (OR UNSIGNED)
	SUBS Z,Q,QREG STALL		;ELSE NEGATE Q, STALL WITH Q DISPLAYED
4$:	ADD  Z,Q STALL			;DISPLAY QUOTIENT
	.PAGE
	.SBTTL USER'S CUSTOM CODE
	.SBTTL CLIP-CLIPPING ROUTINE GIVEN TWO POINTS
;CLIP-CLIPPING ROUTINE GIVEN TWO POINTS
;
;THIS ROUTINE USES A BINARY APPROXIMATION TO FIND A POINT
;
;ON THE BOUNDARY OF THE WINDOW. THE DEFINITION OF A
;
;POINT IN THE WINDOW IS X>ZH AND X>Y>-X.
;
;ENTRY	(X1,Y1)=POINT IN WINDOW
;	(X2,Y2)=POINT NOT IN WINDOW
;	(N)=NUMBER OF ITERATIONS+1 USED
;	(ZH)=MINIMUM EDGE FOR WINDOW
;EXIT	(X1,Y1)=POINT IN WINDOW=
;USES	X1,Y1,X2,Y2,X3,Y3,N
SYHSC:	LDH RY
CLIP:	ADD Z,X1,QREG		;X3=(X1+X2)/2
	ADD X2,Q,BREG X3 RAMD SIGN
	ADD Z,Y1,QREG		;Y3=(Y1+Y2)/2
	ADD Y2,Q,BREG Y3 RAMD SIGN
	LJT 14$
	SUBS RZH,X3,JPL		;IF X=< ZH THEN (X3,Y3)NOT IN WINDOW
	SUBS Y3,X3,JPL		;IF X=< Y THEN (X3,Y3)NOT IN WINDOW
	ADD X3,Y3,QREG		;IF -X >= Y THEN (X3,Y3)NOT IN WINDOW
	SUBS Z,Q,JPL
	ADD ZA,X3,X1,RAMF	;X1=X3, Y1=Y3
	ADD ZA,Y3,Y1,RAMF
11$:	LJT CLIP		;N=N-1
	DEC RN,RAMF,JPL		;LOOP TIL N=-1
	ADD Z,Y1,STALL		;STOP
	
14$:	ADD ZA,X3,X2,RAMF	;X2=X3,Y2=Y3
	ADD ZA,Y3,Y2,RAMF
	JMP 11$
	.PAGE
	.SBTTL DISTANCE ROUTINE GIVEN TWO POINTS
DSTNCE:	LDH RD
	LJT 10$
	SUBR RA,RC,RAMF		;DELTA X
	ADD Z,RC,JPL		;TAKE ABS VAL
	SUBS Z,RC,RAMF
10$:	LJT DST2
	SUBR RB,RD,RAMF		;DELTA Y
	ADD Z,RD,JPL		;TAKE ABS VAL
	SUBS Z,RD,RAMF
DST2:	ADD ZA,RC,T0,RAMF	;MOVE SMALLER TO T0, LARGE TO T1
	ADD ZA,RD,T1,RAMF
	LJT 30$
	SUBR RC,RD,NOP,JPL
	ADD ZA,RD,T0,RAMF
	ADD ZA,RC,T1,RAMF
30$:	ADD Z,T0,RAMD		;T1=T1+(2/3*T0)
	ADD Z,T0,RAMD
	ADD T0,T1,RAMF
	ADD Z,T0,RAMD
	ADD T0,T1,RAMF,STALL
	.PAGE
	.SBTTL MAPPING PROM CODE
	.=8400
	.MACRO MAPOF I,J,K,L
	.BYTE I-PSTART/8
	.IIF NB,J, .BYTE J-PSTART/8
	.IIF NB,K, .BYTE K-PSTART/8
	.IIF NB,L, .BYTE L-PSTART/8
	.ENDM
REGD	=RDISP-PSTART/8
REGS	=RSTO-PSTART/8
RNUM	=0
	.REPT 11.
	.BYTE REGS+RNUM
RNUM	=RNUM+1
	.ENDR
	MAPOF SYHSM
	.BYTE 2*RN+REGS
	.BYTE 2*RZL+REGS
	.BYTE 2*RZL+1+REGS
	.BYTE 2*RZH+REGS
	.BYTE 2*RZH+1+REGS
	MAPOF SYHSMP,MULYP,DIVYP,DIVZ
	.BYTE 2*RXP+REGS
	.BYTE 2*RXP+1+REGS
	.BYTE RXP+REGD
	.BYTE RYPL+REGD
	.BYTE RYP+REGD
	.BYTE 2*RYP+REGS
	.BYTE 2*RYP+1+REGS
	MAPOF SYHSC
	MAPOF DSTNCE
	MAPOF DST2
	.END

                                                                                                                                                                                                                                                                                                           